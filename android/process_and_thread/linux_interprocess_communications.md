# Linux 进程间通信

Android 是基于 Linux 系统的，学习 Android 的进程间通信，需要对 Linux 的进程间通信有点了解，所有咱们从 Linux 进程间为啥需要通信讲起。


程序的执行过程大概是这样的：运算器从存储器读取指令，进行运算，然后把结构存放回存储器。比如汇编了有个 mov 指令，大概长这个样子：

    mov a 0

意思是说把 0 这个值赋给 a 这个地址，这条指令结束后，a 这个地址的值变成了 0 

Note：上面的表述是很不严谨的，详细的过程可以看看计算机组成原理，冯诺伊曼体系结构以及汇编语言等相关书籍。

咱们再回到比汇编语言更高级的语言上，比如 C 或者 C++ ，C 和 C++ 有个概念叫指针。指针可以理解为内存地址，咱们在操作指针的时候，其实操作的是内存地址。指针的指针的意思是指针指向的内存单元存放的数据也是一个内存地址，这个内存地址指向的内存单元存放的数据才是最终的数据。

在写 C/C++ 程序的时候，有个东西叫野指针，当出现野指针的时候就会出现意想不到的结果，你打算修改一个变量的值，你以为你当前手里的指针表示的是这个变量，其实这个指针已经不知道指向哪了（别问我为什么，因为出bug了），于是你修改了这个变量，结果是你想要修改的变量没有别修改，修改的是一个未知的内存单元。

如果出现这种情况，会产生什么样的结果？一是你自己的程序出现问题了，你要修改的变量没有被修改，你还以为它被修改了。同时，真正被你修改的内存单元，可能是另外一个程序要使用的，而这个程序在访问这个内存单元的时候，它以为它获取到它想要的值，其实这个值已经不知道变成什么鬼了。

就好比你回家把你家的灯的开关打开了，结果隔壁老王家的灯泡亮了。万一隔壁老王正在换灯泡，他以为灯是关着的， 其实灯是开着的，老王很可能会崩溃的。

操作系统上跑着 N 多个应用程序，它肯定不希望应用程序之间相互干扰，所有操作系统会为每个应用程序分配指定的内存，并且不允许它们之间直接访问对方的内存。

咱们可以把每个应用程序理解为进程，其实并不是。在进程启动的时候，操作系统会为进程分配内存空间，相互之间不干预。但是问题来了，进程之间是需要合作的，很多时候，一个单独的进程并不能完成所有的工作，或者说一个进程要独立完成所有工作，那么这个进程就会异常复杂。

Linux 进程间通信的方式有很多种

## 管道(PIPE) 和有名管道(FIFO)

管道就是在进程间创建一个标准的输入输出，A 进程往管道里写字节流，B 进程从管道里读字节流，这是单向的，如果需要双向的就需要建立两个管道。可以把它理解为水管。

有名管道跟管道的原理基本一样，区别是可以理解为它是写在一个临时文件里的，只要有读权限，都可以往里写，只要有读权限，都可以往外读。

## 信号(Signal)

一个进程可以向其他进程发送一个信号，用来告诉对方自己发生了某些变化。

## 消息队列

进程可以创建和打开一个消息队列，并且往队列里添加消息。同样，其他拥有这个队列访问权限的进程也可以往里添加消息。拥有读权限的进程可以从消息队列里取走消息。

## 共享内存(share memory)

共享内存的意思是同一个内存被映射到两个或者多个进程的内存空间里，当有一个进程修改了这块内存的内容，其他进程也能同时看到内存内容的变化。多个进程操作同一块内存，就需要有同步机制。共享内存的方式是效率最高的一种。

## 信号量(semaphore)

信号量，也叫信号灯。大体上是为了解决多个进程对同一个资源的占用问题。这种通信机制包括一个信号量的变量，一个进程队列，以及PV操作。P 操作的时候，如果信号量变量不为 0 ，则占用一个资源，同时变量减一，如果信号量为 0 ，则进入等待队列。V 操作的时候，如果等待队列有进程，则把资源交给队列里的一个进程，如果队列里没有进程，就直接释放该资源，同时信号量变量加一。这跟排队上厕所很像。

## 套接字(Socket)

一个进程可以创建一个 Socket 的服务端，并且绑定到某个端口上，其他进程可以通过 ip 地址和端口号与这个进程建立连接。Socket 方式可以实现不同主机上不同进程的通信，这是其他同步禁止不能做到的。

上面很多分析是基于个人理解，应该会有很多错误，而且不严谨。

## 参考资料

[6 Linux Interprocess Communications](http://www.tldp.org/LDP/lpg/node7.html)